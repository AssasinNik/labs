{
    "name": "neo4j-sink",
    "config": {
      "connector.class": "streams.kafka.connect.sink.Neo4jSinkConnector",
      "topics": "postgres.public.department,postgres.public.lecture,postgres.public.groups,postgres.public.student,postgres.public.schedule,postgres.public.course",
      "neo4j.server.uri": "bolt://neo4j:7687",
      "neo4j.authentication.basic.username": "",
      "neo4j.authentication.basic.password": "",
      "neo4j.topic.cypher.postgres.public.department": "CALL apoc.do.case([{condition: event.op = 'c', statement: 'MERGE (d:Department {id: event.after.id}) SET d.name = event.after.name, d.neo_id = \"neo_dept_\" + event.after.id RETURN d'}, {condition: event.op = 'u', statement: 'MATCH (d:Department {id: event.after.id}) SET d.name = event.after.name RETURN d'}, {condition: event.op = 'd', statement: 'MATCH (d:Department {id: event.before.id}) DETACH DELETE d'}], '', {event: event}) YIELD value RETURN value",
      "neo4j.topic.cypher.postgres.public.course": "CALL apoc.do.case([{condition: event.op = 'c', statement: 'MERGE (c:Course {id: event.after.id}) SET c.name = event.after.name, c.id_department = event.after.id_department RETURN c'}, {condition: event.op = 'u', statement: 'MATCH (c:Course {id: event.after.id}) SET c.name = event.after.name, c.id_department = event.after.id_department RETURN c'}, {condition: event.op = 'd', statement: 'MATCH (c:Course {id: event.before.id}) DETACH DELETE c'}], '', {event: event}) YIELD value RETURN value",
      "neo4j.topic.cypher.postgres.public.lecture": "CALL apoc.do.case([{condition: event.op = 'c', statement: 'MATCH (c:Course {id: event.after.id_course}) MERGE (l:Lecture {id: event.after.id}) SET l.name = event.after.name WITH l, c MATCH (d:Department {id: c.id_department}) MERGE (l)-[:ORIGINATES_FROM]->(d) RETURN l'}, {condition: event.op = 'u', statement: 'MATCH (l:Lecture {id: event.after.id}) SET l.name = event.after.name WITH l MATCH (l)-[r:ORIGINATES_FROM]->() DELETE r WITH l MATCH (c:Course {id: event.after.id_course}) MATCH (d:Department {id: c.id_department}) MERGE (l)-[:ORIGINATES_FROM]->(d) RETURN l'}, {condition: event.op = 'd', statement: 'MATCH (l:Lecture {id: event.before.id}) DETACH DELETE l'}], '', {event: event}) YIELD value RETURN value",
      "neo4j.topic.cypher.postgres.public.groups": "CALL apoc.do.case([{condition: event.op = 'c', statement: 'MERGE (g:Group {id: event.after.id}) SET g.name = event.after.name, g.mongo_id = event.after.mongo_id RETURN g'}, {condition: event.op = 'u', statement: 'MATCH (g:Group {id: event.after.id}) SET g.name = event.after.name, g.mongo_id = event.after.mongo_id RETURN g'}, {condition: event.op = 'd', statement: 'MATCH (g:Group {id: event.before.id}) DETACH DELETE g'}], '', {event: event}) YIELD value RETURN value",
      "neo4j.topic.cypher.postgres.public.student": "CALL apoc.do.case([{condition: event.op = 'c', statement: 'MATCH (g:Group {id: event.after.id_group}) MERGE (s:Student {student_number: event.after.student_number}) SET s.fullname = event.after.fullname, s.redis_key = event.after.redis_key MERGE (s)-[:BELONGS_TO]->(g) RETURN s'}, {condition: event.op = 'u', statement: 'MATCH (s:Student {student_number: event.after.student_number}) SET s.fullname = event.after.fullname, s.redis_key = event.after.redis_key WITH s MATCH (s)-[r:BELONGS_TO]->() DELETE r WITH s MATCH (g:Group {id: event.after.id_group}) MERGE (s)-[:BELONGS_TO]->(g) RETURN s'}, {condition: event.op = 'd', statement: 'MATCH (s:Student {student_number: event.before.student_number}) DETACH DELETE s'}], '', {event: event}) YIELD value RETURN value",
      "neo4j.topic.cypher.postgres.public.schedule": "CALL apoc.do.case([{condition: event.op = 'c', statement: 'MATCH (g:Group {id: event.after.id_group}) MATCH (l:Lecture {id: event.after.id_lecture}) MERGE (g)-[:HAS_SCHEDULE {date: datetime(event.after.timestamp), location: event.after.location}]->(l) RETURN g, l'}, {condition: event.op = 'u', statement: 'MATCH (g:Group {id: event.after.id_group})-[r:HAS_SCHEDULE]->(l:Lecture {id: event.after.id_lecture}) SET r.date = datetime(event.after.timestamp), r.location = event.after.location RETURN g, l'}, {condition: event.op = 'd', statement: 'MATCH (g:Group {id: event.before.id_group})-[r:HAS_SCHEDULE]->(l:Lecture {id: event.before.id_lecture}) DELETE r'}], '', {event: event}) YIELD value RETURN value",
      "key.converter": "org.apache.kafka.connect.json.JsonConverter",
      "value.converter": "org.apache.kafka.connect.json.JsonConverter",
      "key.converter.schemas.enable": "false",
      "value.converter.schemas.enable": "false",
      "errors.tolerance": "all",
      "errors.log.enable": "true",
      "errors.log.include.messages": "true"
    }
  }
  