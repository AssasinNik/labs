{
  "name": "neo4j-sink",
  "config": {
    "connector.class": "streams.kafka.connect.sink.Neo4jSinkConnector",
    "topics": "postgres.public.department,postgres.public.lecture_department,postgres.public.groups,postgres.public.student,postgres.public.schedule",
    "neo4j.server.uri": "bolt://neo4j:7687",
    "neo4j.authentication.basic.username": "",
    "neo4j.authentication.basic.password": "",
    "neo4j.database": "neo4j",
    "neo4j.topic.cypher.postgres.public.department": "CALL apoc.do.case([event.op IN ['c','r'], 'MERGE (d:Department {id: event.after.id}) SET d.name = event.after.name, d.neo_id = event.after.neo_id, d.created_at = event.after.created_at, d.updated_at = event.after.updated_at RETURN d', event.op = 'u', 'MATCH (d:Department {id: event.after.id}) SET d.name = event.after.name, d.neo_id = event.after.neo_id, d.updated_at = event.after.updated_at RETURN d', event.op = 'd', 'MATCH (d:Department {id: event.before.id}) DETACH DELETE d RETURN d'], '', {event:event}) YIELD value RETURN value",
    "neo4j.topic.cypher.postgres.public.lecture_department": "CALL apoc.do.case([event.op IN ['c','r'], 'MERGE (l:Lecture {id: event.after.lecture_id}) SET l.name = event.after.lecture_name, l.id_course = event.after.id_course, l.id_department = event.after.id_department, l.department_name = event.after.department_name WITH l OPTIONAL MATCH (l)-[r:ORIGINATES_FROM]->() DELETE r WITH l MATCH (d:Department {id: l.id_department}) MERGE (l)-[:ORIGINATES_FROM]->(d) RETURN l', event.op = 'u', 'MATCH (l:Lecture {id: event.after.lecture_id}) SET l.name = event.after.lecture_name, l.id_course = event.after.id_course, l.id_department = event.after.id_department, l.department_name = event.after.department_name WITH l OPTIONAL MATCH (l)-[r:ORIGINATES_FROM]->() DELETE r WITH l MATCH (d:Department {id: l.id_department}) MERGE (l)-[:ORIGINATES_FROM]->(d) RETURN l', event.op = 'd', 'MATCH (l:Lecture {id: event.before.lecture_id}) DETACH DELETE l RETURN l'], '', {event:event}) YIELD value RETURN value",
    "neo4j.topic.cypher.postgres.public.groups": "CALL apoc.do.case([event.op IN ['c','r'], 'MERGE (g:Group {id: event.after.id}) SET g.name = event.after.name, g.mongo_id = event.after.mongo_id, g.formation_year = event.after.formation_year, g.created_at = event.after.created_at, g.department_id = event.after.id_department RETURN g', event.op = 'u', 'MATCH (g:Group {id: event.after.id}) SET g.name = event.after.name, g.mongo_id = event.after.mongo_id, g.formation_year = event.after.formation_year, g.department_id = event.after.id_department RETURN g', event.op = 'd', 'MATCH (g:Group {id: event.before.id}) DETACH DELETE g RETURN g'], '', {event:event}) YIELD value RETURN value",
    "neo4j.topic.cypher.postgres.public.student": "CALL apoc.do.case([event.op IN ['c','r'], 'MERGE (s:Student {student_number: event.after.student_number}) SET s.fullname = event.after.fullname, s.email = event.after.email, s.redis_key = event.after.redis_key, s.created_at = event.after.created_at, s.group_id = event.after.id_group WITH s OPTIONAL MATCH (s)-[r:BELONGS_TO]->() DELETE r WITH s MATCH (g:Group {id: s.group_id}) MERGE (s)-[:BELONGS_TO]->(g) RETURN s', event.op = 'u', 'MATCH (s:Student {student_number: event.after.student_number}) SET s.fullname = event.after.fullname, s.email = event.after.email, s.redis_key = event.after.redis_key, s.group_id = event.after.id_group WITH s OPTIONAL MATCH (s)-[r:BELONGS_TO]->() DELETE r WITH s MATCH (g:Group {id: s.group_id}) MERGE (s)-[:BELONGS_TO]->(g) RETURN s', event.op = 'd', 'MATCH (s:Student {student_number: event.before.student_number}) DETACH DELETE s RETURN s'], '', {event:event}) YIELD value RETURN value",
    "neo4j.topic.cypher.postgres.public.schedule": "CALL apoc.do.case([event.op IN ['c','r'], 'MATCH (g:Group {id: event.after.id_group}), (l:Lecture {id: event.after.id_lecture}) MERGE (g)-[r:HAS_SCHEDULE {id: event.after.id}]->(l) SET r.location = event.after.location, r.date = event.after.timestamp RETURN g,l,r', event.op = 'u', 'MATCH (g)-[r:HAS_SCHEDULE {id: event.after.id}]->(l) WHERE g.id <> event.after.id_group OR l.id <> event.after.id_lecture DELETE r WITH event MATCH (g:Group {id: event.after.id_group}), (l:Lecture {id: event.after.id_lecture}) MERGE (g)-[r:HAS_SCHEDULE {id: event.after.id}]->(l) SET r.location = event.after.location, r.date = event.after.timestamp RETURN g,l,r', event.op = 'd', 'MATCH (g:Group)-[r:HAS_SCHEDULE {id: event.before.id}]->(l:Lecture) DELETE r RETURN g,l'], '', {event:event}) YIELD value RETURN value",
    "key.converter": "org.apache.kafka.connect.json.JsonConverter",
    "key.converter.schemas.enable": "true",
    "value.converter": "org.apache.kafka.connect.json.JsonConverter",
    "value.converter.schemas.enable": "false",
    "errors.tolerance": "all",
    "errors.log.enable": "true",
    "errors.log.include.messages": "true",
    "neo4j.batch.size": 100,
    "neo4j.batch.timeout": 5000
  }
}